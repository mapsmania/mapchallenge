<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Minimal London</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link
    href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; background: #000; font-family: 'Inter', sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #london-label {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: #fff;
      font-weight: 900; /* Made bold to stand out against dark background */
      font-size: 15vw; /* scales with viewport width */
      line-height: 1;
      pointer-events: none;
      user-select: none;
      z-index: 10;
    }
    .live-plane {
      width: 8px; /* Dot size */
      height: 8px;
      background-color: #fff; /* White dot */
      border-radius: 50%;
      box-shadow: 0 0 4px 1px rgba(255, 255, 255, 0.8);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="london-label">LDN</div>
  
  <!-- Removed: The plane counter HTML has been removed from here. -->

  <script>
    const UPDATE_INTERVAL = 10000; // 10 seconds for fetching
    const ANIMATION_DURATION = UPDATE_INTERVAL; // Duration for interpolation

    // Create the map with no basemap or style layers
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {},
        layers: [],
        glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
      },
      center: [-0.1, 51.5], // approximate London center
      zoom: 10 // Start a bit zoomed out
    });

    let livePlanes = {}; // { icao24: { marker, startPos, targetPos, startTime } }
    let animationFrameId = null;

    // --- Core Logic for Smooth Plane Movement ---

    // 1. Animation Loop (runs constantly to interpolate positions)
    function animatePlanes() {
      const now = Date.now();
      
      for (const id in livePlanes) {
        const plane = livePlanes[id];
        const elapsed = now - plane.startTime;
        
        // Progress is a value between 0 and 1, limiting it to 1
        const progress = Math.min(1, elapsed / ANIMATION_DURATION); 

        if (progress <= 1) {
          const startLng = plane.startPos[0];
          const startLat = plane.startPos[1];
          const targetLng = plane.targetPos[0];
          const targetLat = plane.targetPos[1];

          // Linear interpolation for smooth movement
          const currentLng = startLng + (targetLng - startLng) * progress;
          const currentLat = startLat + (targetLat - startLat) * progress;

          plane.marker.setLngLat([currentLng, currentLat]);
        }
      }

      // Removed: document.getElementById('plane-count').textContent = activePlanes;
      animationFrameId = requestAnimationFrame(animatePlanes);
    }

    // 2. Fetch and Update Data
    async function fetchLivePlanes() {
      const bounds = map.getBounds();
      const lamin = bounds.getSouth();
      const lomin = bounds.getWest();
      const lamax = bounds.getNorth();
      const lomax = bounds.getEast();

      // OpenSky Network API
      const url = `https://opensky-network.org/api/states/all?lamin=${lamin}&lomin=${lomin}&lamax=${lamax}&lomax=${lomax}`;

      try {
        const res = await fetch(url);
        const data = await res.json();
        updateLivePlanes(data.states || []);
      } catch (err) {
        console.error("Error fetching plane data (network or API issue)", err);
      }
    }

    // 3. Update Plane States
    function updateLivePlanes(states) {
      const seen = new Set();
      const now = Date.now();

      states.forEach(plane => {
        const icao24 = plane[0];
        const callsign = plane[1];
        const lon = plane[5]; // Longitude
        const lat = plane[6]; // Latitude
        
        const track = plane[10]; 

        if (!lat || !lon) return;

        seen.add(icao24);

        if (livePlanes[icao24]) {
          // Plane exists: Update the target position and reset the start time/position
          const currentPos = livePlanes[icao24].marker.getLngLat();

          livePlanes[icao24].startPos = [currentPos.lng, currentPos.lat];
          livePlanes[icao24].targetPos = [lon, lat];
          livePlanes[icao24].startTime = now;

        } else {
          // New Plane: Create new marker
          const el = document.createElement("div");
          el.className = "live-plane";
          // Add a title with callsign or ICAO for detail on hover
          el.title = `Callsign: ${callsign || 'N/A'}\nICAO: ${icao24}`;

          const marker = new maplibregl.Marker({ element: el })
            .setLngLat([lon, lat])
            .addTo(map);

          livePlanes[icao24] = { 
            marker, 
            startPos: [lon, lat], 
            targetPos: [lon, lat], // Target is immediately the same as start for new planes
            startTime: now 
          };
        }
      });

      // Remove planes no longer in view
      for (const id in livePlanes) {
        if (!seen.has(id)) {
          livePlanes[id].marker.remove();
          delete livePlanes[id];
        }
      }
    }
    
    // --- Map Initialization ---

    map.on('load', () => {
      // 1. Add GeoJSON source using the external file path.
      map.addSource('london', {
        type: 'geojson',
        data: 'data/miles.geojson'
      });

      // 2. River Thames Layer
      map.addLayer({
        id: 'thames',
        type: 'line',
        source: 'london',
        layout: { 'line-cap': 'round', 'line-join': 'round' },
        paint: {
          'line-color': '#0077cc', // Blue for water
          'line-width': ['interpolate', ['linear'], ['zoom'], 10, 6, 14, 14] // Responsive width
        },
        filter: ['==', ['get', 'name'], 'River Thames']
      });

      // 3. Bridges Layer
      map.addLayer({
        id: 'bridges',
        type: 'line',
        source: 'london',
        paint: {
          'line-color': '#fff',
          'line-width': 1.5
        },
        filter: ['==', ['get', 'name'], 'bridge']
      });

      // 4. Adjust view to fit all features by fetching the GeoJSON
      const bounds = new maplibregl.LngLatBounds();
      fetch('data/miles.geojson')
        .then(resp => {
            if (!resp.ok) throw new Error(`Failed to load miles.geojson: ${resp.statusText}`);
            return resp.json();
        })
        .then(data => {
          data.features.forEach(f => {
            const coords = f.geometry.coordinates.flat(Infinity);
            // This loop assumes coordinates are simple arrays of [lng, lat] pairs
            for (let i = 0; i < coords.length; i += 2) {
              bounds.extend([coords[i], coords[i + 1]]);
            }
          });
          map.fitBounds(bounds, { padding: 40 });
        })
        .catch(err => {
            console.error("Could not load or process data/miles.geojson. Map bounds may be incorrect.", err);
        });

      // 5. Start fetching and animation
      fetchLivePlanes();
      setInterval(fetchLivePlanes, UPDATE_INTERVAL);
      animatePlanes(); // Start the interpolation loop
    });
  </script>
</body>
</html>
