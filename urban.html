<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Roads, Runways & Rivers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #canvas {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 300px;
      height: 300px;
      border-radius: 50%;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    #buttons {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #buttons button {
      background-color: #1f73b7;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: background-color 0.2s, transform 0.1s;
    }
    #buttons button:hover {
      background-color: #155a91;
      transform: translateY(-1px);
    }
    #buttons button:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <canvas id="canvas"></canvas>
  <div id="buttons">
    <button id="roadBtn">Roads</button>
    <button id="runwayBtn">Runways</button>
    <button id="riverBtn">Rivers</button>
  </div>

  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://tiles.openfreemap.org/styles/positron',
      center: [-73.992, 40.734],
      zoom: 12,
      hash: true
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-left');

    const h = 300;
    const r = h / 2;
    const numBins = 64;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = canvas.height = h;
    if (window.devicePixelRatio > 1) {
      canvas.width = canvas.height = h * 2;
      ctx.scale(2, 2);
    }

    let layerType = 'road'; // default

    document.getElementById('roadBtn').onclick = () => { layerType = 'road'; updateOrientations(); };
    document.getElementById('runwayBtn').onclick = () => { layerType = 'runway'; updateOrientations(); };
    document.getElementById('riverBtn').onclick = () => { layerType = 'river'; updateOrientations(); };

    // ----------------- Helpers -----------------
    function lineclip(points, bbox) {
      const [xMin, yMin, xMax, yMax] = bbox;
      const result = [];
      for (let i = 0; i < points.length - 1; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[i + 1];
        if ((x1 < xMin && x2 < xMin) || (x1 > xMax && x2 > xMax) ||
            (y1 < yMin && y2 < yMin) || (y1 > yMax && y2 > yMax)) continue;
        result.push([points[i], points[i + 1]]);
      }
      return result;
    }

    const R = 6371;
    function toRad(deg) { return deg * Math.PI / 180; }
    function bearingDistance(a, b) {
      const [lon1, lat1] = a.map(toRad);
      const [lon2, lat2] = b.map(toRad);
      const dLon = lon2 - lon1;
      const dLat = lat2 - lat1;

      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;

      const d = 2 * R * Math.asin(Math.sqrt(
        Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2
      ));
      return {bearing, distance: d};
    }

    function analyzeLine(bins, line, isTwoWay) {
      for (let i = 0; i < line.length - 1; i++) {
        const {bearing, distance} = bearingDistance(line[i], line[i + 1]);
        const k0 = Math.round((bearing + 360) * numBins / 360) % numBins;
        const k1 = Math.round((bearing + 180) * numBins / 360) % numBins;
        bins[k0] += distance;
        if (isTwoWay) bins[k1] += distance;
      }
    }

    function interpolateSinebow(t) {
      t = 0.5 - t;
      const rr = Math.floor(250 * Math.pow(Math.sin(Math.PI * (t + 0 / 3)), 2));
      const gg = Math.floor(250 * Math.pow(Math.sin(Math.PI * (t + 1 / 3)), 2));
      const bb = Math.floor(250 * Math.pow(Math.sin(Math.PI * (t + 2 / 3)), 2));
      return `rgb(${rr},${gg},${bb})`;
    }

    const highlightLayerId = 'orientation-highlight';

    function updateOrientations() {
      ctx.clearRect(0, 0, h, h);
      const bearing = map.getBearing();
      ctx.save();
      ctx.translate(r, r);
      ctx.rotate(-bearing * Math.PI / 180);

      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, 2*Math.PI);
      ctx.fill();

      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.moveTo(-r, 0); ctx.lineTo(r, 0);
      ctx.moveTo(0, -r); ctx.lineTo(0, r);
      ctx.stroke();

      const layers = layerType === 'road'
        ? ['highway_major_casing','highway_minor']
        : layerType === 'runway'
          ? ['aeroway-runway']
          : ['waterway']; // Rivers

      const features = map.queryRenderedFeatures({ layers });
      if (!features || !features.length) { ctx.restore(); return; }

      const bounds = map.getBounds();
      const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
      const bins = new Float64Array(numBins);
      const lineContributions = [];

      for (const f of features) {
        const geom = f.geometry;
        const lines = geom.type === 'LineString' ? [geom.coordinates] : geom.coordinates;
        const clippedLines = [];
        for (const line of lines) clippedLines.push(...lineclip(line, bbox));

        for (const line of clippedLines) {
          const segmentBins = new Float64Array(numBins);
          for (let i = 0; i < line.length - 1; i++) {
            const {bearing, distance} = bearingDistance(line[i], line[i + 1]);
            const k0 = Math.round((bearing + 360) * numBins / 360) % numBins;
            const k1 = Math.round((bearing + 180) * numBins / 360) % numBins;
            bins[k0] += distance;
            segmentBins[k0] += distance;
            if (f.properties && f.properties.oneway !== 'true') {
              bins[k1] += distance;
              segmentBins[k1] += distance;
            }
          }
          lineContributions.push({line, segmentBins});
        }
      }

      const binMax = Math.max(...bins) || 1;

      // Draw orientation rose
      for (let i = 0; i < numBins; i++) {
        const a0 = ((i - 0.5) * 360 / numBins - 90) * Math.PI / 180;
        const a1 = ((i + 0.5) * 360 / numBins - 90) * Math.PI / 180;
        ctx.fillStyle = interpolateSinebow((2*i % numBins)/numBins);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, r * Math.sqrt(bins[i]/binMax), a0, a1);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      // Highlight segments on the map
      if (map.getLayer(highlightLayerId)) map.removeLayer(highlightLayerId);
      if (map.getSource(highlightLayerId)) map.removeSource(highlightLayerId);

      const geojson = {
        type: 'FeatureCollection',
        features: []
      };

      for (const seg of lineContributions) {
        const total = seg.segmentBins.reduce((a,b) => a+b, 0);
        if (total === 0) continue;
        const frac = total / binMax;
        const color = `rgba(255,0,0,${Math.min(frac*2,1)})`;
        geojson.features.push({
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: seg.line },
          properties: { color }
        });
      }

      map.addSource(highlightLayerId, { type: 'geojson', data: geojson });
      map.addLayer({
        id: highlightLayerId,
        type: 'line',
        source: highlightLayerId,
        paint: {
          'line-color': ['get', 'color'],
          'line-width': 3
        }
      });
    }

    map.on('load', () => {
      updateOrientations();
      map.on('moveend', updateOrientations);
    });
  </script>
</body>
</html>
